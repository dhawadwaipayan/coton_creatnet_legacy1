// Render Handler - Handles both fastrack and accurate modes
// Separate proxy handler for render operations

import { GoogleGenerativeAI } from '@google/generative-ai';

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

export async function handleRenderFastrack(action, data) {
  console.log('[Render Handler] handleRenderFastrack called with:', { action, dataKeys: Object.keys(data) });
  const { base64Sketch, base64Material, additionalDetails } = data;
  
  if (!base64Sketch) {
    throw new Error('Missing base64Sketch for render fastrack');
  }

  // Get base prompt from environment variable
  const basePrompt = process.env.RENDER_FASTRACK_KEY;
  
  if (!basePrompt) {
    throw new Error('RENDER_FASTRACK_KEY environment variable is not configured');
  }

  // Use base prompt and append additional details if provided
  let finalPromptText = basePrompt;
  
  if (additionalDetails && additionalDetails.trim()) {
    finalPromptText += ` ${additionalDetails.trim()}`;
    console.log('[Render Handler] Using RENDER_FASTRACK_KEY + additional details, total length:', finalPromptText.length);
    console.log('[Render Handler] Additional details:', additionalDetails.trim());
  } else {
    console.log('[Render Handler] Using RENDER_FASTRACK_KEY only, length:', finalPromptText.length);
  }

  // Clean base64 data
  const cleanBase64 = base64Sketch.replace(/^data:image\/[a-z]+;base64,/, '');
  const cleanMaterialBase64 = base64Material ? base64Material.replace(/^data:image\/[a-z]+;base64,/, '') : null;

  // Return base64 data for direct download (no Supabase needed)
  const downloadData = `data:image/png;base64,${cleanBase64}`;

  // Get the model
  const model = genAI.getGenerativeModel({ 
    model: "gemini-2.5-flash-image-preview" 
  });

  // Generate content (following old geminiService.ts logic)
  const result = await model.generateContent([
    finalPromptText,
    {
      inlineData: {
        mimeType: "image/png",
        data: cleanBase64
      }
    },
    // Add material image if provided
    ...(cleanMaterialBase64 ? [{
      inlineData: {
        mimeType: "image/png",
        data: cleanMaterialBase64
      }
    }] : [])
  ]);

  const response = await result.response;
  
  // Extract the generated image data
  const generatedImage = response.candidates?.[0]?.content?.parts?.find(
    part => part.inlineData && part.inlineData.mimeType?.startsWith('image/')
  );

  if (!generatedImage?.inlineData?.data) {
    throw new Error('No image generated by Gemini API');
  }

  const imageData = generatedImage.inlineData.data;

  // Let AI determine the aspect ratio - don't force any specific dimensions
  // The AI will return whatever aspect ratio it thinks is best for the input
  console.log('[Render Handler] Using AI-determined aspect ratio');

  // Return in format expected by client
  return {
    success: true,
    mode: "Render Model (Gemini)",
    model_used: "gemini-2.5-flash-image-preview",
    output: [{
      type: "image_generation_call",
      result: imageData
    }],
    message: "Fashion render complete using Gemini AI",
    imageDimensions: {
      width: 1024,
      height: 1536,
      aspectRatio: 1024 / 1536
    },
    downloadData: downloadData // Base64 data for direct download
  };
}

export async function handleRenderAccurate(action, data) {
  console.log('[Render Handler] handleRenderAccurate called with:', { action, dataKeys: Object.keys(data) });
  const { base64Sketch, base64Material, additionalDetails } = data;
  
  if (!base64Sketch) {
    throw new Error('Missing base64Sketch for render accurate');
  }

  // For accurate mode, use OpenAI (implement as needed)
  // This is a placeholder - implement actual OpenAI call
  throw new Error('Render accurate mode not implemented yet');
}

export async function handleRenderPro(action, data) {
  console.log('[Render Handler] handleRenderPro called with:', { action, dataKeys: Object.keys(data) });
  const { base64Sketch, base64Material, additionalDetails, userId } = data;
  
  if (!base64Sketch) {
    throw new Error('Missing base64Sketch for render pro');
  }

  if (!userId) {
    throw new Error('Missing userId for render pro');
  }

  // Import Supabase client
  const { createClient } = await import('@supabase/supabase-js');
  const supabaseUrl = 'https://mtflgvphxklyzqmvrdyw.supabase.co';
  const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  const supabase = createClient(supabaseUrl, supabaseServiceRoleKey);

  // Clean base64 data
  const cleanBase64 = base64Sketch.replace(/^data:image\/[a-z]+;base64,/, '');
  const imageBuffer = Buffer.from(cleanBase64, 'base64');

  // Upload image to Supabase board-images bucket
  const imageId = `render_pro_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  const imagePath = `temp-images/${imageId}.png`;

  console.log('[Render Pro] Uploading image to Supabase board-images bucket');

  const { data: uploadData, error: uploadError } = await supabase.storage
    .from('board-images')
    .upload(imagePath, imageBuffer, {
      contentType: 'image/png',
      upsert: false
    });

  if (uploadError) {
    throw new Error(`Failed to upload image to Supabase: ${uploadError.message}`);
  }

  // Get public URL for Segmind API
  const { data: publicUrlData } = await supabase.storage
    .from('board-images')
    .getPublicUrl(imagePath);

  if (!publicUrlData?.publicUrl) {
    throw new Error('Failed to get public URL for image');
  }

  console.log('[Render Pro] Image uploaded, calling Segmind API with public URL:', publicUrlData.publicUrl);

  // Prepare Segmind API request with public URL
  const segmindRequest = {
    Base64Sketch: publicUrlData.publicUrl, // Send public URL to Segmind
    Additional_Details: additionalDetails || ''
  };

  // Call Segmind API
  const segmindResponse = await fetch('https://api.segmind.com/workflows/68cdb1828ed0001726e0f151-v2', {
    method: 'POST',
    headers: {
      'x-api-key': process.env.SEGMIND_API_KEY,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(segmindRequest)
  });

  if (!segmindResponse.ok) {
    const errorText = await segmindResponse.text();
    console.error('[Render Pro] Segmind API error:', {
      status: segmindResponse.status,
      statusText: segmindResponse.statusText,
      error: errorText
    });
    throw new Error(`Segmind API error: ${segmindResponse.status} - ${errorText}`);
  }

  const segmindResult = await segmindResponse.json();
  console.log('[Render Pro] Segmind response:', segmindResult);

  // Cleanup temp image from board-images bucket
  try {
    await supabase.storage
      .from('board-images')
      .remove([imagePath]);
    console.log('[Render Pro] Cleaned up temporary image');
  } catch (cleanupError) {
    console.warn('[Render Pro] Failed to cleanup temporary image:', cleanupError);
  }

  // Poll for completion on server side
  console.log('[Render Pro] Starting server-side polling...');
  
  let attempts = 0;
  const maxAttempts = 30; // 90 seconds total
  
  while (attempts < maxAttempts) {
    try {
      console.log(`[Render Pro] Polling attempt ${attempts + 1}/${maxAttempts}`);
      
      const pollResponse = await fetch(segmindResult.poll_url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': process.env.SEGMIND_API_KEY
        }
      });
      
      if (!pollResponse.ok) {
        throw new Error(`Polling failed: ${pollResponse.status}`);
      }
      
      const pollResult = await pollResponse.json();
      console.log('[Render Pro] Poll result:', pollResult);
      
      // Check if processing is complete
      if (pollResult.status === 'COMPLETED' && pollResult.RenderPro_Output) {
        console.log('[Render Pro] Processing completed successfully');
        
        // Fetch the final image
        const imageResponse = await fetch(pollResult.RenderPro_Output);
        if (!imageResponse.ok) {
          throw new Error('Failed to fetch final image');
        }
        
        const imageBuffer = await imageResponse.arrayBuffer();
        const imageBase64 = Buffer.from(imageBuffer).toString('base64');
        
        // Return in the same format as other render modes
        return {
          success: true,
          mode: "Render Pro (Segmind)",
          model_used: "segmind-workflow-v2",
          output: [{
            type: "image_generation_call",
            result: imageBase64
          }],
          message: "Fashion render complete using Segmind AI",
          imageDimensions: {
            width: 1024,
            height: 1536,
            aspectRatio: 1024 / 1536
          },
          downloadData: `data:image/png;base64,${cleanBase64}`
        };
      } else if (pollResult.status === 'FAILED') {
        const errorDetails = pollResult.error_message || pollResult.error || 'Unknown error';
        console.error('[Render Pro] Segmind processing failed:', errorDetails);
        throw new Error(`Segmind processing failed: ${JSON.stringify(errorDetails)}`);
      }
      
      // Still processing, wait and try again
      await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3 seconds
      attempts++;
      
    } catch (error) {
      console.error('[Render Pro] Polling error:', error);
      throw error;
    }
  }
  
  throw new Error('Segmind processing timeout - maximum attempts reached');
}
