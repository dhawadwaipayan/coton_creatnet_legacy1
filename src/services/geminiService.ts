// Following the referenced GitHub repository structure for services
// Updated to use AI Proxy for network security

import { callGeminiAI } from '../lib/aiProxyService';

// Utility function to get image dimensions from base64 data
const getImageDimensions = (base64Data: string): Promise<{ width: number; height: number }> => {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.naturalWidth, height: img.naturalHeight });
    };
    img.onerror = () => {
      // Fallback to default dimensions if image loading fails
      resolve({ width: 1024, height: 1536 });
    };
    img.src = `data:image/png;base64,${base64Data}`;
  });
};

export interface GeminiImageResult {
  imageData: string;
  width: number;
  height: number;
  aspectRatio: number;
}

export const generateImage = async (imageData: string, materialImage?: string, additionalDetails?: string): Promise<GeminiImageResult> => {
  console.log('[GeminiService] generateImage called via AI Proxy with additionalDetails:', additionalDetails);
  console.log('[GeminiService] additionalDetails type:', typeof additionalDetails);
  console.log('[GeminiService] additionalDetails value:', additionalDetails);
  console.log('[GeminiService] additionalDetails trimmed:', additionalDetails?.trim());
  
  try {
    // Clean base64 data (remove data:image/png;base64, prefix if present)
    const cleanBase64 = imageData.replace(/^data:image\/[a-z]+;base64,/, '');
    
    // Clean material image data if provided
    const cleanMaterialBase64 = materialImage ? materialImage.replace(/^data:image\/[a-z]+;base64,/, '') : null;
    
    // Structured JSON-style base prompt for fashion sketch to photorealistic render
    let promptText = `{
  "task": "fashion_sketch_to_realistic_render",
  "input": {
    "sketch_image": "base64Sketch",
    "material_reference": "base64Material || null",
    "reference_style": "high-resolution fashion photography",
    "model_preferences": {
      "pose": "neutral runway stance, arms relaxed",
      "height": "tall",
      "body_type": "slim but natural proportions",
      "skin": "natural texture with soft shading"
    },
    "garment_rendering": {
      "fabric_mode": "use material_reference if provided, else follow sketch fabric accurately (color, drape, texture, scale)",
      "lighting": "studio lighting, soft shadows",
      "background": "solid white",
      "focus": "maintain garment accuracy while producing photorealistic output"
    }
  }
}`;

    // Add additional details if provided by the user
    if (additionalDetails && additionalDetails.trim()) {
      promptText += `\n\nAdditional User Requirements: ${additionalDetails.trim()}`;
    }
    
    console.log('[GeminiService] Final promptText:', promptText);
    console.log('[GeminiService] Prompt length:', promptText.length);
    
    // Call Gemini AI through the AI proxy
    const proxyResponse = await callGeminiAI(cleanBase64, promptText, false);
    const result = proxyResponse.result;
    
    // Extract the generated image data from the proxy response
    const generatedImage = result.candidates?.[0]?.content?.parts?.find(
      part => part.inlineData && part.inlineData.mimeType?.startsWith('image/')
    );

    if (!generatedImage?.inlineData?.data) {
      throw new Error('No image generated by Gemini API via proxy');
    }

    // Get image dimensions by creating a temporary image element
    const dimensions = await getImageDimensions(generatedImage.inlineData.data);
    
    console.log('[GeminiService] Image generated successfully via AI Proxy:', {
      width: dimensions.width,
      height: dimensions.height,
      aspectRatio: dimensions.aspectRatio
    });
    
    return {
      imageData: generatedImage.inlineData.data,
      width: dimensions.width,
      height: dimensions.height,
      aspectRatio: dimensions.width / dimensions.height
    };
  } catch (error) {
    console.error('[GeminiService] Error generating image via AI Proxy:', error);
    throw error;
  }
};

/**
 * Transform Gemini response to match the existing render API format
 * This ensures compatibility with the current render system
 */
export const transformGeminiResponse = (geminiResult: GeminiImageResult, additionalDetails?: string) => {
  return {
    success: true,
    mode: "fastrack",
    model_used: "gemini-2.5-flash-image-preview",
    enhanced_prompt: additionalDetails && additionalDetails.trim() 
      ? `Fashion sketch to realistic render with detailed specifications. Additional requirements: ${additionalDetails.trim()}`
      : "Fashion sketch to realistic render with detailed specifications",
    output: [{
      type: "image_generation_call",
      result: geminiResult.imageData,
      enhanced_description: additionalDetails && additionalDetails.trim()
        ? `Professional fashion render generated by Gemini 2.5 Flash with material reference support. Custom requirements: ${additionalDetails.trim()}`
        : "Professional fashion render generated by Gemini 2.5 Flash with material reference support"
    }],
    message: "Fashion render complete using Gemini 2.5 Flash",
    // Include dimension information for aspect ratio handling
    imageDimensions: {
      width: geminiResult.width,
      height: geminiResult.height,
      aspectRatio: geminiResult.aspectRatio
    }
  };
};
